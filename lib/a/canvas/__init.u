import a.webview
import a.json
import .htmlevents

html_content = r###"
<html>
    <head>
        <style>
            html, body, canvas {
                margin: 0px;
                padding: 0px;
                width: 100%%;
                height: 100%%;
                overflow: hidden;
            }
        </style>
    </head>
    <body>
        <canvas id="canvas"></canvas>
        <script>%s</script>
    </body>
</html>
"### % [htmlevents.CODE]


def init(
    title = '',
    size = [800, 600],
    resizable = false,
    debug = false,
    frameless = false,
    delegatecls = nil,
) = {
    delegate = nil
    Canvas(webview.init(
        title = title,
        content = html_content,
        size = size,
        resizable = resizable,
        debug = debug,
        frameless = frameless,
        handler = def(arg) {
            nonlocal delegate
            parts = arg.split('/').list()
            switch parts[0] {
                'init' => {
                    delegate = delegatecls()
                }
                'click' => {
                    [btn, x, y] = parts[1:]
                    ordie(delegate.click(int(btn), float(x), float(y)))
                }
                'mousemove' => {
                    [x, y] = parts[1:]
                    ordie(delegate.mousemove(float(x), float(y)))
                }
                'mousedown' => {
                    [btn, x, y] = parts[1:]
                    ordie(delegate.mousedown(int(btn), float(x), float(y)))
                }
                'mouseup' => {
                    [btn, x, y] = parts[1:]
                    ordie(delegate.mouseup(int(btn), float(x), float(y)))
                }
                'keydown' => {
                    [key, mods] = parts[1:]
                    mods = mods.split(',').list()
                    ordie(delegate.keydown(key, mods))
                }
                'keyup' => {
                    [key, mods] = parts[1:]
                    mods = mods.split(',').list()
                    ordie(delegate.keyup(key, mods))
                }
                'keypress' => {
                    [key, mods] = parts[1:]
                    mods = mods.split(',').list()
                    ordie(delegate.keypress(key, mods))
                }
                'resize' => {
                    [width, height] = parts[1:]
                    ordie(delegate.resize(width, height))
                }
                => {
                    print('Unrecognized cmd %r' % [parts])
                }
            }
        },
    ), def(new_delegate) {
        nonlocal delegate
        delegate = new_delegate
    })
}

class Canvas {
    new(wv, swap_delegate) = new(webview=wv, swap_delegate=swap_delegate)

    def run(self) {
        self.webview.run()
    }

    def exit(self) {
        self.webview.exit()
    }

    def delegate(self, delegatecls) {
        delegate = delegatecls()
        (self.swap_delegate)(delegate)
    }

    def __set_fullscreen(self, flag) {
        # Ugh, this doesn't seem to work consistently...
        # :/ setting fullscreen twice seems to work better?
        self.webview.set_fullscreen(flag)
        self._eval('updateCanvasDim()')
        self.webview.set_fullscreen(flag)
        self._eval('updateCanvasDim()')
    }

    def _aeval(self, js) = self.webview.async_eval(js)
    def _eval(self, js) = self.webview.eval(js)
    async def _evaljson(self, js) = {
        s = await self._aeval('JSON.stringify(%s)' % [js])
        json.loads(s)
    }

    async def __get_width(self) = await self._aeval('canvas.width')
    async def __get_height(self) = await self._aeval('canvas.height')

    # Lots of reference from
    # https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D

    # Drawing rectangles
    def clearRect(self, x, y, width, height) {
        self._eval('ctx.clearRect(%r, %r, %r, %r)' % [x, y, width, height])
    }
    def fillRect(self, x, y, width, height) {
        self._eval('ctx.fillRect(%r, %r, %r, %r)' % [x, y, width, height])
    }
    def strokeRect(self, x, y, width, height) {
        self._eval('ctx.strokeRect(%r, %r, %r, %r)' % [x, y, width, height])
    }

    # Drawing Text
    def fillText(self, text, x, y) {
        self._eval('ctx.fillText(%r, %r, %r)' % [text, x, y])
    }
    def strokeText(self, text, x, y) {
        self._eval('ctx.strokeText(%r, %r, %r)' % [text, x, y])
    }
    async def measureText(self, text) = {
        resp = await self._aeval('JSON.stringify(measureText(%r))' % [text])
        json.loads(resp)
    }

    # Line styles
    async def __get_lineWidth(self) = float(await self._aeval('ctx.lineWidth'))
    def __set_lineWidth(self, width) {
        self._eval('ctx.lineWidth = %r' % [width])
    }
    async def __get_lineCap(self) = await self._aeval('ctx.lineCap')
    def __set_lineCap(self, cap) {
        # Type of endings on the end of lines.
        # Possible values: butt (default), round, square.
        self._eval('ctx.lineCap = %r' % [cap])
    }
    async def __get_lineJoin(self) = await self._aeval('ctx.lineJoin')
    def __set_lineJoin(self, cap) {
        # Defines the type of corners where two lines meet.
        # Possible values: round, bevel, miter (default).
        self._eval('ctx.lineJoin = %r' % [cap])
    }
    async def __get_miterLimit(self) = float(await self._aeval('ctx.miterLimit'))
    def __set_miterLimit(self, cap) {
        # Miter limit ratio. Default 10.
        self._eval('ctx.miterLimit = %r' % [cap])
    }
    async def getLineDash(self) = await self._evaljson('ctx.getLineDash()')
    def setLineDash(self, segments) {
        self._eval('ctx.setLineDash(%s)' % [json.dumps(segments)])
    }
    async def __get_lineDashOffset(self) = {
        float(await self._aeval('ctx.lineDashOffset'))
    }
    def __set_lineDashOffset(self, cap) {
        # Specifies where to start a dash array on a line.
        self._eval('ctx.lineDashOffset = %r' % [cap])
    }

    # Text styles
    async def __get_font(self) = await self._aeval('ctx.font')
    def __set_font(self, font) {
        font = str(font)
        self._eval('ctx.font = "%s"' % [font])
    }
    async def __get_textAlign(self) = await self._aeval('ctx.textAlign')
    def __set_textAlign(self, textAlign) {
        # Text alignment setting.
        # Possible values: start (default), end, left, right, center.
        textAlign = str(textAlign)
        self._eval('ctx.textAlign = "%s"' % [textAlign])
    }
    async def __get_textBaseline(self) = await self._aeval('ctx.textBaseline')
    def __set_textBaseline(self, textBaseline) {
        # Baseline alignment setting.
        # Possible values: top, hanging, middle, alphabetic (default),
        # ideographic, bottom.
        textBaseline = str(textBaseline)
        self._eval('ctx.textBaseline = "%s"' % [textBaseline])
    }
    async def __get_direction(self) = await self._aeval('ctx.direction')
    def __set_direction(self, direction) {
        # Directionality. Possible values: ltr, rtl, inherit (default).
        direction = str(direction)
        self._eval('ctx.direction = "%s"' % [direction])
    }

    # Fill and stroke styles
    def __set_fillStyle(self, fillStyle) {
        fillStyle = str(fillStyle)
        self._eval('ctx.fillStyle = "%s"' % [fillStyle])
    }
    async def __get_fillStyle(self) = await self._aeval('ctx.fillStyle')

    def __set_strokeStyle(self, strokeStyle) {
        strokeStyle = str(strokeStyle)
        self._eval('ctx.strokeStyle = "%s"' % [strokeStyle])
    }
    async def __get_strokeStyle(self) = await self._aeval('ctx.strokeStyle')
}

class Delegate {
    def resize(self, width, height) = nil
    def click(self, btn, x, y) = nil
    def mousemove(self, x, y) = nil
    def mousedown(self, btn, x, y) = nil
    def mouseup(self, btn, x, y) = nil
    def keydown(self, key, mods) = nil
    def keyup(self, key, mods) = nil
    def keypress(self, key, mods) = nil
}
