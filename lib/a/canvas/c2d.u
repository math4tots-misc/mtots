import a.json

class Canvas2DMixin {
    # Wraps the HTML5 canvas 2D API, largely following the methods on
    # CanvasRenderingContext2D as documented here:
    # https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D
    #
    # Any method that returns a value is async, as the returned value needs to
    # make a round trip to and from the webview.

    # Drawing rectangles
    def clearRect(self, x, y, width, height) {
        self.eval0('ctx.clearRect(%r, %r, %r, %r)' % [x, y, width, height])
    }
    def fillRect(self, x, y, width, height) {
        self.eval0('ctx.fillRect(%r, %r, %r, %r)' % [x, y, width, height])
    }
    def strokeRect(self, x, y, width, height) {
        self.eval0('ctx.strokeRect(%r, %r, %r, %r)' % [x, y, width, height])
    }

    # Drawing Text
    def fillText(self, text, x, y) {
        self.eval0('ctx.fillText(%r, %r, %r)' % [text, x, y])
    }
    def strokeText(self, text, x, y) {
        self.eval0('ctx.strokeText(%r, %r, %r)' % [text, x, y])
    }
    async def measureText(self, text) = {
        self.evalj('measureText(%r)' % [text]).await
    }

    # Line styles
    async def __get_lineWidth(self) = float(self.evals('ctx.lineWidth').await)
    def __set_lineWidth(self, width) {
        self.eval0('ctx.lineWidth = %r' % [width])
    }
    async def __get_lineCap(self) = self.evals('ctx.lineCap').await
    def __set_lineCap(self, cap) {
        # Type of endings on the end of lines.
        # Possible values: butt (default), round, square.
        self.eval0('ctx.lineCap = %r' % [cap])
    }
    async def __get_lineJoin(self) = self.evals('ctx.lineJoin').await
    def __set_lineJoin(self, cap) {
        # Defines the type of corners where two lines meet.
        # Possible values: round, bevel, miter (default).
        self.eval0('ctx.lineJoin = %r' % [cap])
    }
    async def __get_miterLimit(self) = float(self.evals('ctx.miterLimit').await)
    def __set_miterLimit(self, cap) {
        # Miter limit ratio. Default 10.
        self.eval0('ctx.miterLimit = %r' % [cap])
    }
    async def getLineDash(self) = self.evalj('ctx.getLineDash()').await
    def setLineDash(self, segments) {
        self.eval0('ctx.setLineDash(%s)' % [json.dumps(segments)])
    }
    async def __get_lineDashOffset(self) = {
        float(self.evals('ctx.lineDashOffset').await)
    }
    def __set_lineDashOffset(self, cap) {
        # Specifies where to start a dash array on a line.
        self.eval0('ctx.lineDashOffset = %r' % [cap])
    }

    # Text styles
    async def __get_font(self) = self.evals('ctx.font').await
    def __set_font(self, font) {
        font = str(font)
        self.eval0('ctx.font = "%s"' % [font])
    }
    async def __get_textAlign(self) = self.evals('ctx.textAlign').await
    def __set_textAlign(self, textAlign) {
        # Text alignment setting.
        # Possible values: start (default), end, left, right, center.
        textAlign = str(textAlign)
        self.eval0('ctx.textAlign = "%s"' % [textAlign])
    }
    async def __get_textBaseline(self) = self.evals('ctx.textBaseline').await
    def __set_textBaseline(self, textBaseline) {
        # Baseline alignment setting.
        # Possible values: top, hanging, middle, alphabetic (default),
        # ideographic, bottom.
        textBaseline = str(textBaseline)
        self.eval0('ctx.textBaseline = "%s"' % [textBaseline])
    }
    async def __get_direction(self) = self.evals('ctx.direction').await
    def __set_direction(self, direction) {
        # Directionality. Possible values: ltr, rtl, inherit (default).
        direction = str(direction)
        self.eval0('ctx.direction = "%s"' % [direction])
    }

    # Fill and stroke styles
    def __set_fillStyle(self, fillStyle) {
        fillStyle = str(fillStyle)
        self.eval0('ctx.fillStyle = "%s"' % [fillStyle])
    }
    async def __get_fillStyle(self) = self.evals('ctx.fillStyle').await
    def __set_strokeStyle(self, strokeStyle) {
        strokeStyle = str(strokeStyle)
        self.eval0('ctx.strokeStyle = "%s"' % [strokeStyle])
    }
    async def __get_strokeStyle(self) = self.evals('ctx.strokeStyle').await

    # Paths
    def beginPath(self) = self.eval0('ctx.beginPath()')
    def closePath(self) = self.eval0('ctx.closePath()')
    def moveTo(self, x, y) = self.eval0('ctx.moveTo(%r, %r)' % [x, y])
    def lineTo(self, x, y) = self.eval0('ctx.lineTo(%r, %r)' % [x, y])
    def bezierCurveTo(self, cp1x, cp1y, cp2x, cp2y, x, y) {
        self.eval0('ctx.bezierCurveTo(%r, %r, %r, %r, %r, %r)' % [
            cp1x, cp1y,
            cp2x, cp2y,
            x, y,
        ])
    }
    def quadraticCurveTo(self, cpx, cpy, x, y) {
        self.eval0('ctx.quadraticCurveTo(%r, %r, %r, %r)' % [
            cpx, cpy,
            x, y,
        ])
    }
    def arc(self, x, y, radius, startAngle, endAngle, anticlockwise=false) {
        self.eval0('ctx.arc(%r, %r, %r, %r, %r, %r)' % [
            x, y, radius, startAngle, endAngle, anticlockwise,
        ])
    }
    def arcTo(self, x1, y1, x2, y2, radius) {
        self.eval0('ctx.arcTo(%r, %r, %r, %r, %r)' % [
            x1, y1, x2, y2, radius
        ])
    }
    def ellipse(
        self,
        x,
        y,
        radiusX,
        radiusY,
        rotation,
        startAngle,
        endAngle,
        anticlockwise=false,
    ) {
        self.eval0('ctx.ellipse(%r, %r, %r, %r, %r, %r, %r, %r)' % [
            x,
            y,
            radiusX,
            radiusY,
            rotation,
            startAngle,
            endAngle,
            anticlockwise,
        ])
    }
    def rect(self, x, y, width, height) {
        self.eval0('ctx.rect(%r, %r, %r, %r)' % [x, y, width, height])
    }

    # Drawing paths
    def fill(self, fillRule='nonzero') {
        fillRule = str(fillRule)
        self.eval0('ctx.fill(%r)' % [fillRule])
    }
    def stroke(self) {
        self.eval0('ctx.stroke()')
    }
    def clip(self) {
        self.eval0('ctx.clip()')
    }

    # The canvas state
    def save(self) {
        self.eval0('ctx.save()')
    }
    def restore(self) {
        self.eval0('ctx.restore()')
    }

    # Drawing images
    async def drawImage(
            self,
            image,
            sx,
            sy,
            sWidth=nil,
            sHeight=nil,
            dx=nil,
            dy=nil,
            dWidth=nil,
            dHeight=nil,
    ) {
        # void ctx.drawImage(image, dx, dy);
        # void ctx.drawImage(image, dx, dy, dWidth, dHeight);
        # void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
        ctx = self.ctx().await
        if sWidth is nil {
            ctx.drawImage(image, sx, sy).await
        } elif dx is nil {
            ctx.drawImage(image, sx, sy, sWidth, sHeight).await
        } else {
            ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight).await
        }
    }
}
