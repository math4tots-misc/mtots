# The play screen
import ggez
import ...model::Model
import ...model::Board
import time

def update(app, model) {
    _init = false

    [R, C] = [model.R(), model.C()]

    board_screen_x = board_screen_y = 0
    width = height = board_screen_width = board_screen_height = nil
    cell_height = cell_width = nil

    board = range(R).map(def(_) = [nil] * C).list()

    board_color = ggez::Color(0.3, 0.5, 0.8)
    background_color = ggez::Color(0.8, 0.5, 0.3).scale(0.5)
    piece_color = ggez::Color(1.0, 0.0, 0.7)
    filled_color = ggez::Color(0.8, 0.8, 0.8)

    def init(ctx) {
        nonlocal width, height, board_screen_height, board_screen_width
        nonlocal board_screen_x, board_screen_y
        nonlocal cell_width, cell_height
        [width, height] = ctx.size()
        board_screen_x = width * 0.05
        board_screen_y = height * 0.05
        board_screen_width = (width * 0.9) / 2
        board_screen_height = height * 0.9
        cell_height = board_screen_height / R
        cell_width = board_screen_width / C
    }

    def draw_background(ctx) {
        ggez::MeshBuilder().rect(
            0, 0, width, height, background_color,
        ).build(ctx).draw(ctx)
    }

    def draw_board_background(ctx) {
        ggez::MeshBuilder().rect(
            board_screen_x,
            board_screen_y,
            board_screen_width,
            board_screen_height,
            board_color,
        ).build(ctx).draw(ctx)
    }

    def board_cell_xy(r, c) = {
        x0 = board_screen_x + c * cell_width
        y0 = board_screen_y + r * cell_height
        [x0, y0]
    }

    def draw_board(ctx) {
        for [r, c] in model.board().filled_cells() {
            [x, y] = board_cell_xy(r, c)
            mb = ggez::MeshBuilder()
            mb.rect(x, y, cell_width, cell_height, filled_color)
            mb.build(ctx).draw(ctx)
        }
        nil.map(model.piece(), def(piece) = {
            for [r, c] in piece.occupied_cells() {
                [x, y] = board_cell_xy(r, c)
                mb = ggez::MeshBuilder()
                mb.rect(x, y, cell_width, cell_height, piece_color)
                mb.build(ctx).draw(ctx)
            }
        })
    }

    def draw_score(ctx) {
        state = model.state()

        rhs_x = width * 0.55
        rhs_y = height * 0.1
        score_text = ggez::SimpleText(
            "cleared lines = " + str(model.cleared_line_count()),
            scale=width / 50,
        )
        score_text.draw(ctx, [rhs_x, rhs_y])

        if state is :lose {
            go_text = ggez::SimpleText("GAME OVER")
            text_width = go_text.width(ctx)
            text_height = go_text.height(ctx)
            go_text.draw(ctx, [width / 2 - text_width / 2, height / 2 - text_height / 2])
        }
    }

    app.update(
        update = def(ctx) {
            nonlocal _init
            if _init is false {
                init(ctx)
                _init = true
            }
            model.tick(time::now())
        },
        draw = def(ctx) {
            draw_background(ctx)
            draw_board_background(ctx)
            draw_board(ctx)
            draw_score(ctx)
        },
        key_down = def(ctx, key, mods) {
            if mods == [] or mods == [:repeat] {
                if key is :Escape {
                    ctx.quit()
                } elif key is :A or key is :Left {
                    model.move_left()
                } elif key is :D or key is :Right {
                    model.move_right()
                } elif key is :S or key is :Down {
                    model.move_down()
                } elif key is :W or key is :Up {
                    model.rotate()
                } elif key is :Space or key is :Return {
                    model.hard_drop()
                } else {
                    print('Unrecognized key: %r' % [key])
                }
            } else {
                print('Unhandled key combo: [%r, %r]' % [key, mods])
            }
        },
        gamepad_button_down = def(ctx, button, gamepad) {
            if button is :DPadLeft {
                model.move_left()
            } elif button is :DPadRight {
                model.move_right()
            } elif button is :DPadDown {
                model.move_down()
            } elif button is :South {
                model.rotate()
            } elif button is :East {
                model.rotate(3)
            } elif button is :North {
                model.hard_drop()
            } elif button is :West {
                model.restart()
            } else {
                print('Unrecognized gamepad button %r, %r' % [button, gamepad])
            }
        },
    )
}
