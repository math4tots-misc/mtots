import _ggez


class Color {
    [opaque]

    static def __call(r, g, b, a=1.0) = {
        opaque = _ggez::new_color(r, g, b, a)
        __malloc(Color, [opaque])
    }
}

BLACK = Color(0, 0, 0)
WHITE = Color(1, 1, 1)
RED = Color(1, 0, 0)
GREEN = Color(0, 1, 0)
BLUE = Color(0, 0, 1)

class Context {
    [opaque]

    def size(self) = _ggez::size(self.opaque)

    def fps(self) = _ggez::ctx_fps(self.opaque)
}

class MeshBuilder {
    [opaque]

    static def __call() = {
        __malloc(MeshBuilder, [_ggez::new_mesh_builder()])
    }

    def circle(self, center, radius, color) = {
        _ggez::mesh_builder_circle(self.opaque, center, radius, color.opaque)
        self
    }

    def build(self, ctx) = {
        Drawable(_ggez::mesh_builder_build(self.opaque, ctx.opaque))
    }
}

class Drawable {
    [opaque]

    static def __call(opaque) = __malloc(Drawable, [opaque])

    def draw(self, ctx, dest=nil) = {
        dest = dest or [0, 0]
        _ggez::draw(ctx.opaque, self.opaque, dest)
    }
}

get_all_keycodes = _ggez::get_all_keycodes

_app_info_keys = [
    :name,
    :author,
    :sleep_per_frame,
]

_app_callback_keys = [
    :update,
    :draw,
    :mouse_down,
    :key_down,
    :text_input,
]

class App {
    [_info_table, _callback_table]

    static def __call(name='name', author='author', sleep_per_frame=nil, **kwargs) = {
        info_table = Table(
            name=name,
            author=author,
            sleep_per_frame=sleep_per_frame,
        )
        callback_table = (
            _app_callback_keys
                .map(def(key) = [key, Cell(kwargs.get(key, nil))])
                .to(Table)
        )

        "Ensure there are no extraneous fields"
        assert_eq(callback_table.len(), (kwargs + callback_table).len())

        __malloc(App, [info_table, callback_table])
    }

    def update(self, **kwargs) = {
        """
        Replace all the callbacks for an app.
        Any callback that's not specified will be set to nil.
        """
        for key in _app_callback_keys {
            self._callback_table.get(key).set(kwargs.get(key, nil))
        }
    }

    def main(self) {
        """
        Starts the ggez event loop
        """
        _ggez::start(
            context_class=Context,
            **self._info_table.merge(
                _app_callback_keys.map(def(key) = {
                    [key, self._callback_table.get(key, nil)]
                })
                .to(Table)
            )
        )
    }
}

def demo() = {
    import time

    print(get_all_keycodes())

    width = 0
    height = 0
    x = 0
    y = 0
    last_tick_time = nil
    last_fps_print_time = nil
    init = false

    app = App(
        name="demo",
        update=def(ctx) {
            nonlocal last_tick_time, last_fps_print_time, x, y, width, height, init

            if !init {
                [width, height] = ctx.size()
                x = width / 2
                y = height / 2
                print('init, size -> ' + str(ctx.size()))
                init = true
            }

            now = time::now()
            last_tick_time = if last_tick_time is nil { now } else { last_tick_time }
            last_fps_print_time = if last_fps_print_time is nil {
                now
            } else {
                last_fps_print_time
            }

            if now - last_fps_print_time > 2.1 {
                print('fps = %r' % [ctx.fps()])
                last_fps_print_time = now
            }

            if now - last_tick_time > .4 {
                y = min(y + 20, height - 40)
                last_tick_time = now
            }
        },
        draw=def(ctx) {
            MeshBuilder().circle([40, 40], 40, BLUE).build(ctx).draw(ctx)
            MeshBuilder().circle([width - 40, height - 40], 40, RED).build(ctx).draw(ctx)
            (
                MeshBuilder()
                    .circle([width - 40, 40], 40, GREEN)
                    .circle([40, height - 40], 40, WHITE)
                    .build(ctx)
                    .draw(ctx)
            )
            MeshBuilder().circle([0, 0], 40, BLUE).build(ctx).draw(ctx, [x, y])
        },
        mouse_down=def(ctx, button, cx, cy) = {
            nonlocal x, y
            print('button = %s, cx = %s, cy = %s' % [button, cx, cy])
            if button == :left {
                x = cx
                y = cy
            }
        },
        text_input=def(ctx, c) = {
            nonlocal x, y
            print('text_input c = %r' % [c])
            r###" if c == 'a' {
                x = x - 40
            } elif c == 'd' {
                x = x + 40
            } elif c == 'w' {
                y = y - 40
            } elif c == 's' {
                y = y + 40
            } "###
        },
        key_down=def(ctx, key, mods) = {
            nonlocal x, y
            print('key = %r, mods= %s' % [key, mods])

            if key is :Left or key is :A {
                x = x - 40
            } elif key is :Right or key is :D {
                x = x + 40
            } elif key is :Up or key is :W {
                y = y - 40
            } elif key is :Down or key is :S {
                y = y + 40
            }
        }
    )

    app.main()
}
