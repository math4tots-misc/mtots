import a._three

class Window {
    [opaque, title, camera_opaque_cell]

    static def __call(title) = {
        opaque = _three::new_window(title)
        __malloc(Window, [opaque, title, Cell(nil)])
    }

    def scene(self) = Scene(self)
    def factory(self) = Factory(self)

    def set_camera(self, camera) = self.camera_opaque_cell.set(camera.opaque)

    def main(self, camera, update) {
        if camera is not nil {
            self.camera_opaque_cell.set(camera.opaque)
        }
        _three::main(self.opaque, self.camera_opaque_cell, update)
    }
}

trait ThreeObject {
    # Corresponds to three's Object trait
    # Represents any element in a scene that can be moved, rotated or scaled

    def set_transform(self, pos, rot, scale) {
        # See the set_position, set_orientation, and set_scale
        # methods for meaning of each of these parameters
        _three::set_transform(self.opaque, pos, rot, scale)
    }

    def set_position(self, pos) {
        # Expects [x, y, z] triple for new object location
        # The default value is [0, 0, 0]
        _three::set_position(self.opaque, pos)
    }

    def set_orientation(self, rot) {
        # Expects [x, y, z, theta] 4-tuple, where
        # (x, y, z) represents the axis of rotation and theta is the
        # angle to rotate by, in radians
        # (x, y, z) will automatically be normalized when applying
        # the rotation
        # Without an explicit 'set_orientation' (or set_transform) call,
        # the object is assumed to have no rotation
        _three::set_orientation(self.opaque, rot)
    }

    def set_scale(self, scale) {
        # Expects a single float or int for how much to
        # scale by; the default value is 1.0
        _three::set_scale(self.opaque, scale)
    }

    def look_at(self, eye, target, up=nil) {
        # Expects
        #   eye: [ex, ey, ez] for where to move this object to,
        #   target: triple for where to look at,
        #   up: optionally provided will determine where 'up' will be
        # Useful for quickly setting up the camera
        _three::look_at(self.opaque, eye, target, up)
    }
}

class Scene {
    [window]

    def add(self, item) {
        _three::window_add(self.window.opaque, item.opaque)
    }

    def set_background_color(self, color) {
        _three::set_background_color(self.window.opaque, color)
    }
}

class Factory {
    [window]

    def upload_geometry(self, geometry) = InstancedGeometry(self.window, geometry)
    def mesh(self, geometry, material) = Mesh(self.window, geometry, material)

    def orthographic_camera(self, center, extent_y, range) = {
        # Creates an orthographic camera
        #   center: the 2D (x,y) coordinates of where the center of this view should be
        #   extent_y: ...
        #   range: [min, max] indicating depth of how deep the camera can see
        Camera::orthographic(self.window, center, extent_y, range)
    }

    def perspective_camera(self, fov_y, range) = {
        # Creates a perspective camera
        #   fov_y: field of view, in degrees. If you're not sure, 60 is often a
        #          reasonable value here
        #   range: [min, max?] indicating how far the camera can see
        #          max may be nil, in which case there's no upper limit
        Camera::perspective(self.window, fov_y, range)
    }
}

class Camera(ThreeObject) {
    [opaque]

    static def orthographic(window, center, extent_y, range) = {
        opaque = _three::new_orthographic_camera(window.opaque, center, extent_y, range)
        Camera(opaque)
    }

    static def perspective(window, fov_y, range) = {
        opaque = _three::new_perspective_camera(window.opaque, fov_y, range)
        Camera(opaque)
    }
}

class Geometry {
    [opaque]

    static def with_vertices(vertices) = {
        opaque = _three::new_geometry_from_vertices(vertices)
        __malloc(Geometry, [opaque])
    }

    static def cuboid(width, height, depth) = {
        # Create a new cuboid centered at the origin
        Geometry(_three::new_geometry_cuboid(width, height, depth))
    }

    static def cylinder(radius_top, radius_bottom, height, radius_segments=12) = {
        Geometry(_three::new_geometry_cylinder(radius_top, radius_bottom, height, radius_segments))
    }

    static def uv_sphere(radius, equatorial_segments=12, meridional_segments=12) = {
        # Creates geometry for a sphere using the UV method
        Geometry(_three::new_geometry_uv_sphere(radius, equatorial_segments, meridional_segments))
    }
}

class InstancedGeometry {
    # Geometry that has been loaded to the GPU
    [opaque]

    static def __call(window, geometry) = {
        __malloc(InstancedGeometry, [_three::new_instanced_geometry(window.opaque, geometry.opaque)])
    }
}

class Material {
    [opaque]

    static def basic(color) = {
        opaque = _three::new_material_basic(color)
        Material(opaque)
    }
}

class Mesh(ThreeObject) {
    # Conceptually Geometry + Material
    [opaque]

    static def __call(window, geometry, material) = {
        if type(geometry) is not InstancedGeometry {
            geometry = InstancedGeometry(window, geometry)
        }

        opaque = _three::new_mesh(window.opaque, geometry.opaque, material.opaque)

        __malloc(Mesh, [opaque])
    }
}
