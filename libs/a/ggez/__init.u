import a._ggez


class Color {
    [opaque, r, g, b, a]

    static def __call(r, g=nil, b=nil, a=1.0) = {
        if g is nil {
            if type(r) is Color {
                r
            } elif type(r) is List and r.len() == 3 {
                [r, g, b] = r
                opaque = _ggez::new_color(r, g, b, a)
                __malloc(Color, [opaque, r, g, b, a])
            } else {
                [r, g, b, a] = r
                opaque = _ggez::new_color(r, g, b, a)
                __malloc(Color, [opaque, r, g, b, a])
            }
        } else {
            opaque = _ggez::new_color(r, g, b, a)
            __malloc(Color, [opaque, r, g, b, a])
        }
    }

    def scale(self, r) = Color(
        self.r * r,
        self.g * r,
        self.b * r,
        self.a,
    )
}

BLACK = Color(0, 0, 0)
WHITE = Color(1, 1, 1)
RED = Color(1, 0, 0)
GREEN = Color(0, 1, 0)
BLUE = Color(0, 0, 1)

class Context {
    [opaque]

    def size(self) = _ggez::ctx_size(self.opaque)

    def fps(self) = _ggez::ctx_fps(self.opaque)

    def quit(self) = _ggez::ctx_quit(self.opaque)

    def set_window_size(self, width, height) {
        _ggez::ctx_set_drawable_size(self.opaque, width, height)
    }

    def set_screen_coordinates(self, x, y, width, height) {
        _ggez::ctx_set_screen_coordinates(self.opaque, x, y, width, height)
    }
}

trait Drawable {
    def draw(self, ctx, dest=nil, rotation=nil, scale=nil, offset=nil) = {
        # Draws the given drawable to the screen
        #   ctx: Context object
        #   dest: [x, y] pair indicating destination to draw to (defaults to [0, 0])
        #   rotation: orientation of the graphic in radians (defaults to 0)
        #   scale: [x, y] scale factors (defaults to [1, 1])
        #   offset: offset from the center for transform operations like scale/rotation
        #     [0, 0] meaning upper left corner, and [1, 1] meaning the lower right.
        #     The Rust ggez library defaults this value to [0, 0], but
        #     for convenience, this method defaults this value to [0.5, 0.5]
        if dest is nil { dest = [0, 0] }
        if rotation is nil { rotation = 0 }
        if scale is nil { scale = [1, 1] }
        if offset is nil { offset = [0.5, 0.5] }
        _ggez::ctx_draw(ctx.opaque, self.opaque, dest, rotation, scale, offset)
    }
}

class MeshBuilder {
    [opaque]

    static def __call() = {
        __malloc(MeshBuilder, [_ggez::new_mesh_builder()])
    }

    def circle(self, center, radius, color, tolerance=2.0) = {
        _ggez::mesh_builder_circle(self.opaque, center, radius, tolerance, color.opaque)
        self
    }

    def polygon(self, points, color) = {
        """
        NOTE: The points must be given in clockwise order!
        """
        _ggez::mesh_builder_polygon(self.opaque, points, color.opaque)
        self
    }

    def rect(self, x, y, width, height, color) = {
        self.polygon(
            [
                [x, y],
                [x + width, y],
                [x + width, y + height],
                [x, y + height],
            ],
            color,
        )
    }

    def build(self, ctx) = {
        Mesh(_ggez::mesh_builder_build(self.opaque, ctx.opaque))
    }
}

class Mesh(Drawable) {
    [opaque]
}

trait BaseText(Drawable) {
    def width(self, ctx) = _ggez::text_width(self.opaque, ctx.opaque)
    def height(self, ctx) = _ggez::text_height(self.opaque, ctx.opaque)
}

class SimpleText(BaseText) {
    [opaque]

    static def __call(text, color=nil, scale=nil) = {
        __malloc(SimpleText, [_ggez::new_text_simple(text, color, scale)])
    }
}

class Image(Drawable) {
    [opaque]

    static def colors(ctx, color_rows) = {
        # Create a new image from a 2-D array of Colors
        width = color_rows[0].len()
        height = color_rows.len()
        colors = @[]
        for row in color_rows {
            for color in row {
                colors.push(Color(color).opaque)
            }
        }
        colors = colors.move()
        __malloc(Image, [_ggez::new_image_from_colors(ctx.opaque, width, height, colors)])
    }
}

class SpriteBatch(Drawable) {
    [opaque]

    static def image(image) = {
        # Create a SpriteBatch with an image
        opaque = _ggez::new_sprite_batch_from_image(image.opaque)
        __malloc(SpriteBatch, [opaque])
    }

    def add(self, dest=nil, rotation=nil, scale=nil, offset=nil) = {
        # adds a new sprite in this spritebatch
        # the parameters mirror those in Drawable().draw()
        # Returns a SpriteId object that can be used to update the given sprite
        if dest is nil { dest = [0, 0] }
        if rotation is nil { rotation = 0 }
        if scale is nil { scale = [1, 1] }
        if offset is nil { offset = [0.5, 0.5] }
        opaque = _ggez::sprite_batch_add(self.opaque, dest, rotation, scale, offset)
        SpriteId(opaque)
    }

    def set(self, sprite_id, dest=nil, rotation=nil, scale=nil, offset=nil) = {
        # updates the draw parameters for a sprite in this spritebatch
        # the parameters mirror those in Drawable().draw()
        if dest is nil { dest = [0, 0] }
        if rotation is nil { rotation = 0 }
        if scale is nil { scale = [1, 1] }
        if offset is nil { offset = [0.5, 0.5] }
        _ggez::sprite_batch_set(self.opaque, sprite_id.opaque, dest, rotation, scale, offset)
    }

    def clear(self) {
        # Clears all the sprites in this batch
        _ggez::sprite_batch_clear(self.opaque)
    }
}

class SpriteId {
    [opaque]
}

get_all_keycodes = _ggez::get_all_keycodes

_app_info_keys = [
    :name,
    :author,
    :sleep_per_frame,
]

_app_callback_keys = [
    :update,
    :draw,
    :mouse_down,
    :key_down,
    :text_input,
    :gamepad_button_down,
    :gamepad_axis,
]

class App {
    [_info_table, _callback_table]

    static def __call(name='name', author='author', sleep_per_frame=nil, **kwargs) = {
        info_table = Table(
            name=name,
            author=author,
            sleep_per_frame=sleep_per_frame,
        )
        callback_table = (
            _app_callback_keys
                .map(def(key) = [key, Cell(kwargs.get(key, nil))])
                .to(Table)
        )

        "Ensure there are no extraneous fields"
        assert_eq(callback_table.len(), (kwargs + callback_table).len())

        __malloc(App, [info_table, callback_table])
    }

    def update(self, init=nil, update=nil, **kwargs) = {
        """
        Replace all the callbacks for an app.
        Any callback that's not specified will be set to nil.
        """
        if init is not nil {
            old_update = update
            initialized = false
            def update(ctx) {
                nonlocal initialized
                if !initialized {
                    init(ctx)
                    initialized = true
                }
                if old_update is not nil {
                    old_update(ctx)
                }
            }
        }
        for key in _app_callback_keys {
            self._callback_table.get(key).set(
                if key is :update {
                    update
                } else {
                    kwargs.get(key, nil)
                }
            )
        }
        for key in kwargs.keys() {
            if !_app_callback_keys.has(key) {
                __raise(RuntimeError, 'Unrecognized update key: %r' % [key])
            }
        }
    }

    def main(self) {
        """
        Starts the ggez event loop
        """
        _ggez::start(
            context_class=Context,
            **self._info_table.merge(
                _app_callback_keys.map(def(key) = {
                    [key, self._callback_table.get(key)]
                })
                .to(Table)
            )
        )
    }
}
