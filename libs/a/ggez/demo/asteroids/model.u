# Model for the Asteroids game
# In the model, we primarily work with
# a coordinate system that spans from [0, 0] in the
# upper left corner to [1, 1] in the lower-right corner,
# so that we can work with coordinates independent
# of screen size.
import a.math::fmod
import a.math::TAU
import a.math::cos
import a.math::sin
import a.math::atan2
import a.ggez

@class Model {
    # Asteroids game model
    [screen_width, screen_height, ship, bullets]

    static def __call() = {
        __malloc(Model, [nil, nil, nil, nil])
    }

    def init(self, ctx, screen_width, screen_height) {
        self.screen_width = screen_width
        self.screen_height = screen_height
        self.ship = Ship(ctx, screen_width, screen_height)
        self.bullets = Bullets(ctx, screen_width, screen_height)
    }

    def update(self, ctx, elapsed_time, input_axis_x, input_axis_y) {
        self._update_ship_rotation(input_axis_x, input_axis_y)
        self._update_ship_velocity(elapsed_time, input_axis_x, input_axis_y)
        self.ship.update(ctx, elapsed_time)
        self.bullets.update(ctx, elapsed_time, self.screen_width, self.screen_height)
    }

    def draw(self, ctx) {
        [width, height] = [self.screen_width, self.screen_height]
        self.ship.draw(ctx, width, height)
        self.bullets.draw(ctx, width, height)
    }

    def shoot(self, ctx) {
        [x, y] = self.ship.pos()
        angle = self.ship.rot()
        self.bullets.shoot(x, y, angle)
    }

    def process_movement_input(self, input_axis_x, input_axis_y) {
        self._update_ship_rotation(input_axis_x, input_axis_y)
        self._update_ship_velocity(input_axis_x, input_axis_y)
    }

    def _update_ship_rotation(self, input_axis_x, input_axis_y) {
        if input_axis_x ** 2 + input_axis_y ** 2 > 0.25 {
            self.ship.set_rot(atan2(input_axis_x, input_axis_y))
        }
    }

    def _update_ship_velocity(self, elapsed_time, input_axis_x, input_axis_y) {
        [dx, dy] = self.ship.velocity()
        dx += input_axis_x * elapsed_time
        dy += -input_axis_y * elapsed_time
        self.ship.set_velocity([dx, dy])
    }
}

trait BodyLike {
    # Either a Body, or a class that wraps one
    # Either way, subclasses should implement a 'body()'
    # method that returns the representative Body
    def x(self) = self.body().x
    def y(self) = self.body().y
    def pos(self) = {
        body = self.body()
        [body.x, body.y]
    }
    def set_pos(self, xy) {
        body = self.body()
        [body.x, body.y] = xy
    }
    def rot(self) = self.body().rot
    def set_rot(self, rot) {
        self.body().rot = rot
    }
    def dx(self) = self.body().dx
    def dy(self) = self.body().dy
    def velocity(self) = {
        body = self.body()
        [body.dx, body.dy]
    }
    def set_velocity(self, dxdy) {
        body = self.body()
        [body.dx, body.dy] = dxdy
    }
    def drot(self) = self.body().drot
    def radius(self) = self.body().radius
    def hits(self, other) = {
        # determines whether two BodyLikes are hitting each other
        a_x = self.x()
        a_y = self.y()
        a_r = self.radius()
        b_x = other.x()
        b_y = other.y()
        b_r = other.radius()
        (b_x - a_x) ** 2 + (b_y - a_y) ** 2 <= (a_r + b_r) ** 2
    }
}

@class Body(BodyLike) {
    # Represents a single element that can be displayed
    # on the screen and can potentially collide with other
    # bodies
    #
    #  x, y: coordinates of this Body's location
    #  rot: rotation of this Body
    #  dx, dy: this Body's velocity
    #  drot: the velocity of this Body's rotation
    #  radius: the size of Body's hit-circle
    #
    [x, y, rot, dx, dy, drot, radius]

    def update(self, elapsed_time) {
        # Updates the position of this body based on
        # current velocity and elapsed time, and then
        # moves the corresponding body in the sprite_batch
        x = self.x + elapsed_time * self.dx
        y = self.y + elapsed_time * self.dy
        rot = self.rot + elapsed_time * self.drot
        self.x = fmod(x, 1)
        self.y = fmod(y, 1)
        self.rot = fmod(rot, TAU)
    }

    def body(self) = self
}

@class Bullet(BodyLike) {
    [body, sprite_id]
    def body(self) = self.body

    static def __call(x, y, dx, dy, radius) = {
        body = Body(x, y, 0, dx, dy, 0, radius)
        __malloc(Bullet, [body, nil])
    }

    def update(self, sprite_batch, elapsed_time, width, height) = {
        self.body.update(elapsed_time)
        sprite_batch.set(
            self.sprite_id,
            dest=[self.body.x * width, self.body.y * height],
        )
    }
}

@class Bullets {
    [sprite_batch, bullets, max_bullets, next_reuse_bullet_index]

    static def __call(ctx, screen_width, screen_height, max_bullets=10) = {
        image = ggez::Image::colors(ctx, [
            [[1, 1, 1], [1, 1, 1]],
            [[1, 1, 1], [1, 1, 1]],
        ])
        sprite_batch = ggez::SpriteBatch::image(image)
        bullets = @[]
        __malloc(Bullets, [sprite_batch, bullets, max_bullets, 0])
    }

    def update(self, ctx, elapsed_time, width, height) {
        sprite_batch = self.sprite_batch
        for bullet in self.bullets.clone().move() {
            bullet.update(sprite_batch, elapsed_time, width, height)
        }
    }

    def draw(self, ctx, width, height) {
        self.sprite_batch.draw(ctx)
    }

    def shoot(self, x, y, angle, bullet_radius=0.01, bullet_speed=1) {
        # x, y: where the bullet will start
        # angle: the angle to shoot the bullet from
        #        in radians, where 0 implies north
        #        and positive angle aligns with clockwise
        #        rotation
        dx = bullet_speed * sin(angle)
        dy = bullet_speed * -cos(angle)
        bullet = Bullet(x, y, dx, dy, bullet_radius)
        if self.bullets.len() < self.max_bullets {
            self.bullets.push(bullet)
        } else {
            self.bullets[self.next_reuse_bullet_index] = bullet
            self.next_reuse_bullet_index += 1
            self.next_reuse_bullet_index %= self.max_bullets
        }
        self._reset_sprite_ids()
    }

    def _reset_sprite_ids(self) {
        sprite_batch = self.sprite_batch
        sprite_batch.clear()
        for bullet in self.bullets.clone().move() {
            bullet.sprite_id = sprite_batch.add(
                dest=[bullet.x(), bullet.y()],
            )
        }
    }
}

@class Ship(BodyLike) {
    [body, rotation, mesh]

    static def __call(ctx, screen_width, screen_height) = {
        body = Body(0.5, 0.5, 0, 0, 0, 0, 1 / 35)
        ship_height = screen_height / 30
        ship_width = screen_width / 40
        mesh = ggez::MeshBuilder().polygon(
            [
                [0, -ship_height / 2],
                [ship_width / 2, ship_height / 2],
                [0, ship_height * (-0.5 + 0.75)],
                [-ship_width / 2, ship_height / 2],
            ],
            ggez::WHITE,
        ).build(ctx)
        __malloc(Ship, [body, 0, mesh])
    }

    def body(self) = self.body

    def update(self, ctx, elapsed_time) {
        self.body.update(elapsed_time)
    }

    def draw(self, ctx, screen_width, screen_height) {
        screen_x = self.x() * screen_width
        screen_y = self.y() * screen_height
        self.mesh.draw(
            ctx,
            dest=[screen_x, screen_y],
            rotation=self.rot(),
        )
    }
}

def normalize(xy) = {
    [x, y] = xy
    len = (x * x + y * y) ** 0.5
    [x / len, y / len]
}
