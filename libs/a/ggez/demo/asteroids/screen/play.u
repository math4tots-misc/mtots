# The play screen
import a.ggez
import a.math::TAU
import a.math::atan2
import time

def update(app, model) {

    height = width = nil
    player_mesh = nil
    background_mesh = nil
    model_pos_x = model_pos_y = 0.5
    controller_axis_x = 0
    controller_axis_y = 0
    velocity_x = 0
    velocity_y = 0
    rotation = 0
    last_update_time = nil
    _init = false

    def init(ctx) {
        nonlocal height, width
        nonlocal player_mesh, background_mesh
        nonlocal last_update_time
        [width, height] = ctx.size()
        player_mesh = build_player_mesh(ctx)
        background_mesh = build_background_mesh(ctx)
        last_update_time = time::now()
    }

    def build_background_mesh(ctx) = {
        ggez::MeshBuilder().rect(0, 0, width, height, ggez::BLACK).build(ctx)
    }

    def build_player_mesh(ctx) = {
        player_width = width / 60
        player_height = height / 30

        ggez::MeshBuilder().polygon(
            [
                [0, -player_height / 2],
                [-player_width / 2, player_height / 2],
                [0, player_height * (-0.5 + 0.75)],
                [player_width / 2, player_height / 2],
            ],
            ggez::WHITE,
        ).build(ctx)
    }

    def update_rotation() {
        nonlocal rotation
        if controller_axis_x ** 2 + controller_axis_y ** 2 > 0.25 {
            rotation = TAU * 0.25 + atan2(-controller_axis_y, controller_axis_x)
        }
    }

    def update_velocity(diff) {
        nonlocal velocity_x, velocity_y
        velocity_x += controller_axis_x * diff
        velocity_y += -controller_axis_y * diff
    }

    def normalize_val(x) = {
        while x < 0 {
            x += 1
        }
        while x > 1 {
            x -= 1
        }
        x
    }

    def fix_pos() {
        nonlocal model_pos_x, model_pos_y
        model_pos_x = normalize_val(model_pos_x)
        model_pos_y = normalize_val(model_pos_y)
    }

    def update_pos(diff) {
        nonlocal model_pos_x, model_pos_y
        model_pos_x += velocity_x * diff
        model_pos_y += velocity_y * diff
        fix_pos()
    }

    app.update(
        update=def(ctx) {
            nonlocal _init
            if !_init {
                init(ctx)
                _init = true
            }

            nonlocal last_update_time
            now = time::now()
            diff = now - last_update_time
            last_update_time = now

            update_velocity(diff)
            update_pos(diff)
            # print(['pos', model_pos_x, model_pos_y])
        },
        draw=def(ctx) {
            nonlocal height, width
            [width, height] = ctx.size()
            background_mesh.draw(ctx)
            pos_x = model_pos_x * width
            pos_y = model_pos_y * height
            player_mesh.draw(ctx, dest=[pos_x, pos_y], rotation=rotation)
        },
        key_down=def(ctx, key, mods) {
            if key is :Escape {
                ctx.quit()
            } else {
                print('Unrecognized key %r (%r)' % [key, mods])
            }
        },
        gamepad_button_down=def(ctx, btn, gamepad) {
            if false {
            } else {
                print('Unrecognized button %r (%r)' % [btn, gamepad])
            }
        },
        gamepad_axis=def(ctx, axis, val, gamepad) {
            nonlocal controller_axis_x, controller_axis_y
            if axis is :LeftStickY {
                controller_axis_y = val
                update_rotation()
            } elif axis is :LeftStickX {
                controller_axis_x = val
                update_rotation()
            } else {
                print('Unrecognized axis %r, (%r, %r)' % [axis, val, gamepad])
            }
        },
    )
}
